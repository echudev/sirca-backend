// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: item_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAnalyzer = `-- name: CreateAnalyzer :one
INSERT INTO analyzers (
    item_id,
    brand_id,
    model_id,
    analyzer_state_id,
    analyzer_serialnumber,
    analyzer_pollutant,
    analyzer_last_calibration,
    analyzer_last_maintenance
) VALUES (
    $1,           -- item_id obtenido del primer INSERT en items
    $2,           -- brand_id
    $3,           -- model_id
    $4,           -- analyzer_state_id
    $5,           -- analyzer_serialnumber
    $6,           -- analyzer_pollutant
    $7,           -- analyzer_last_calibration
    $8            -- analyzer_last_maintenance
) RETURNING analyzer_id
`

type CreateAnalyzerParams struct {
	ItemID                  int32       `json:"item_id"`
	BrandID                 int32       `json:"brand_id"`
	ModelID                 int32       `json:"model_id"`
	AnalyzerStateID         int32       `json:"analyzer_state_id"`
	AnalyzerSerialnumber    string      `json:"analyzer_serialnumber"`
	AnalyzerPollutant       string      `json:"analyzer_pollutant"`
	AnalyzerLastCalibration pgtype.Date `json:"analyzer_last_calibration"`
	AnalyzerLastMaintenance pgtype.Date `json:"analyzer_last_maintenance"`
}

func (q *Queries) CreateAnalyzer(ctx context.Context, arg CreateAnalyzerParams) (int32, error) {
	row := q.db.QueryRow(ctx, createAnalyzer,
		arg.ItemID,
		arg.BrandID,
		arg.ModelID,
		arg.AnalyzerStateID,
		arg.AnalyzerSerialnumber,
		arg.AnalyzerPollutant,
		arg.AnalyzerLastCalibration,
		arg.AnalyzerLastMaintenance,
	)
	var analyzer_id int32
	err := row.Scan(&analyzer_id)
	return analyzer_id, err
}

const createItem = `-- name: CreateItem :one
INSERT INTO items (
    item_type_id,
    item_code,
    item_name,
    item_description,
    created_at
) VALUES (
    $1,         -- item_type_id
    $2,         -- item_code (generado en el backend)
    $3,         -- item_name
    $4,         -- item_description
    DEFAULT     -- created_at, usa la marca de tiempo actual
) RETURNING item_id
`

type CreateItemParams struct {
	ItemTypeID      int32       `json:"item_type_id"`
	ItemCode        string      `json:"item_code"`
	ItemName        string      `json:"item_name"`
	ItemDescription pgtype.Text `json:"item_description"`
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) (int32, error) {
	row := q.db.QueryRow(ctx, createItem,
		arg.ItemTypeID,
		arg.ItemCode,
		arg.ItemName,
		arg.ItemDescription,
	)
	var item_id int32
	err := row.Scan(&item_id)
	return item_id, err
}

const getItems = `-- name: GetItems :many
SELECT
    i.item_id,
    i.item_name,
    i.item_description,
    i.created_at,
    it.type_name AS item_type
FROM
    items i
JOIN
    item_types it ON i.item_type_id = it.item_type_id
`

type GetItemsRow struct {
	ItemID          int32              `json:"item_id"`
	ItemName        string             `json:"item_name"`
	ItemDescription pgtype.Text        `json:"item_description"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	ItemType        string             `json:"item_type"`
}

func (q *Queries) GetItems(ctx context.Context) ([]GetItemsRow, error) {
	rows, err := q.db.Query(ctx, getItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemsRow
	for rows.Next() {
		var i GetItemsRow
		if err := rows.Scan(
			&i.ItemID,
			&i.ItemName,
			&i.ItemDescription,
			&i.CreatedAt,
			&i.ItemType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStations = `-- name: GetStations :many
SELECT station_id, station_name, station_image_url, operational_since, station_latitude, station_longitude, station_address
FROM stations
`

type GetStationsRow struct {
	StationID        int32          `json:"station_id"`
	StationName      string         `json:"station_name"`
	StationImageUrl  pgtype.Text    `json:"station_image_url"`
	OperationalSince pgtype.Date    `json:"operational_since"`
	StationLatitude  pgtype.Numeric `json:"station_latitude"`
	StationLongitude pgtype.Numeric `json:"station_longitude"`
	StationAddress   pgtype.Text    `json:"station_address"`
}

func (q *Queries) GetStations(ctx context.Context) ([]GetStationsRow, error) {
	rows, err := q.db.Query(ctx, getStations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStationsRow
	for rows.Next() {
		var i GetStationsRow
		if err := rows.Scan(
			&i.StationID,
			&i.StationName,
			&i.StationImageUrl,
			&i.OperationalSince,
			&i.StationLatitude,
			&i.StationLongitude,
			&i.StationAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
